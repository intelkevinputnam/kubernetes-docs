

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Intel® Device Plug-ins for Kubernetes* &mdash; Kubernetes Documentation  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="GPU Device Plugin" href="gpu.html" />
    <link rel="prev" title="Using Node Feature Discovery in a Kubernetes Cluster" href="../nfd/using.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Kubernetes Documentation
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../nfd/index.html">Node Feature Discovery (NFD)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Intel® Device Plug-ins for Kubernetes*</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gpu.html">GPU Device Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga.html">FPGA Device Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="qat.html">QuickAssist Technology Device Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="vpu.html">VPU Device Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="#device-management-in-kubernetes">Device Management in Kubernetes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#device-plug-in-working-mechanism">Device Plug-in Working Mechanism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#resource-reporting-and-monitoring">Resource Reporting and Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pod-scheduling-and-device-resource-allocation">Pod Scheduling and Device Resource Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handling-kubelet-restarts">Handling Kubelet Restarts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#device-plugin-deployment">Device Plugin Deployment</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-manager/index.html">CPU Resource Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cri-manager/index.html">CRI Resource Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cni/index.html">CNI Bare  metal Container solution for VNF</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Kubernetes Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Intel® Device Plug-ins for Kubernetes*</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/device-plugins/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="intel-device-plug-ins-for-kubernetes">
<h1>Intel® Device Plug-ins for Kubernetes*<a class="headerlink" href="#intel-device-plug-ins-for-kubernetes" title="Permalink to this headline">¶</a></h1>
<p>With deep learning and artificial intelligence being used in many kinds of
areas, heterogeneous computing has become quite hot, so various hardware
providers in the industry have developed heterogeneous computing cards or
hardware accelerators to support those application scenarios. For instance,
Intel® developed several hardware devices to meet those requirements: Intel®
QuickAssist Technology (Intel® QAT), Intel® FPGA, Intel® Artificial
Intelligence and Intel® Server GPU. The intent of this documentation is to
help developers/users understand how to enable and use those Intel® hardware
devices in Kubernetes cluster.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPU Device Plugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="fpga.html">FPGA Device Plugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="qat.html">QuickAssist Technology Device Plugin</a></li>
<li class="toctree-l1"><a class="reference internal" href="vpu.html">VPU Device Plugin</a></li>
</ul>
</div>
<div class="section" id="device-management-in-kubernetes">
<h2>Device Management in Kubernetes<a class="headerlink" href="#device-management-in-kubernetes" title="Permalink to this headline">¶</a></h2>
<p>Usually once a device, device driver, and related develop kits are installed
in system, it is simple to use those heterogeneous cards or devices in host
system and traditional docker container environment with <em>–device</em> and
<em>–volume</em> parameter running, in docker environment, this is docker container
mapping mechanism to use host system resource directly in containers through
<em>–device</em>. but in a Kubernetes cluster environment, resources of these
heterogeneous computing card/device to be bond with container needs to be
managed and allocated by Kubernetes, that means after installing those
heterogeneous computing cards in each computing node, We still need to have a
mechanism to tell the cluster that a certain kinds of heterogeneous card and
the number of cards have been installed on a computing node, and provides
methods so that the cluster can manage and allocate this heterogeneous
computing card resource when application needs placing. in order to have
device resource manage and allocate capability in Kubernetes and adoption for
devices vendors, the Kubernetes is designed to have 2 built-in modules,
<strong>Extended Resource</strong> and <strong>Device Plug-in</strong>, the specific device plug-ins
developed by device vendors will implement scheduling from a device cluster to
working nodes, and then bind devices with containers.</p>
<dl class="simple">
<dt>Extended Resource</dt><dd><p>This is a custom resource expansion method, it belongs to node level API.
It can be used independently. once installed the device and device drivers
in node. the developer needs to report the names and the total number of
the device resources to the Kubernetes API server, the scheduler will
increases or decreases the number of available resources based on the
creation or deletion in the resource pool and determines nodes that satisfy
resource requirements during scheduling. the increment and decrement of
Extended Resource must be integers. for example, you can allocate 1 GPU but
cannot allocate 0.5 GPUs.  it is simple to report extended resources and
update status through a PACTH API, and the PACTH API operation can be
completed through a simple curl command as well.</p>
</dd>
<dt>Device Plug-in</dt><dd><p>It provides a general device plug-in mechanism, called framework and
standard device API interface. device vendors can expand devices such as
the QAT, FPGA, GPU, and VPU by implementing APIs, without modifying the
Kubelet* main code. the device plug-in mechanism is not complex, it’s work
mechanism mainly includes 2 parts, One is for device resource reporting
when start-up, another is for scheduling and allocating when application
needs to access.</p>
</dd>
</dl>
</div>
<div class="section" id="device-plug-in-working-mechanism">
<h2>Device Plug-in Working Mechanism<a class="headerlink" href="#device-plug-in-working-mechanism" title="Permalink to this headline">¶</a></h2>
<p>Today, most equipment vendors are using Device Plug-in mechanism to implement
their specific device plug-in to be integrated into Kubernetes cluster
smoothly without modifying Kubernetes code, with this way to achieve the
equipment scheduling and life cycle management, before knowing how to use
Intel® device plug-ins in Kubernetes, let’s understand device plug-in internal
working mechanism together firstly. Device Plug-in is a simple gRPC server
that implements the methods <code class="docutils literal notranslate"><span class="pre">ListAndWatch</span></code> and <code class="docutils literal notranslate"><span class="pre">Allocate</span></code>, then listens
the Unix sockets under <code class="docutils literal notranslate"><span class="pre">/var/lib/kubelet/device-plugins/</span></code>, such as <code class="docutils literal notranslate"><span class="pre">/var/lib/kubelet/device-plugins/intel-qat.sock</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">service</span> <span class="n">DevicePlugin</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">returns</span> <span class="n">a</span> <span class="n">stream</span> <span class="n">of</span> <span class="p">[]</span><span class="n">Device</span>
    <span class="n">rpc</span> <span class="n">ListAndWatch</span><span class="p">(</span><span class="n">Empty</span><span class="p">)</span> <span class="n">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">ListAndWatchResponse</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">rpc</span> <span class="n">Allocate</span><span class="p">(</span><span class="n">AllocateRequest</span><span class="p">)</span> <span class="n">returns</span> <span class="p">(</span><span class="n">AllocateResponse</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="simple">
<dt>ListAndWatch()</dt><dd><p>It reports device resources and provides health checking of device. when
the device is unhealthy it will be reported to Kubelet and the device
plug-in manager in Kubelet  will remove it’s device ID from the schedulable
list.</p>
</dd>
<dt>Allocate()</dt><dd><p>It is called by device plug-in when deploying a specific container
application. the core parameter is the device ID, then the returned
parameter is the corresponding device path, driver directory, environment
variables which  are required when launching the container application,
let’s see the detail of the process below:</p>
</dd>
</dl>
<div class="section" id="resource-reporting-and-monitoring">
<h3>Resource Reporting and Monitoring<a class="headerlink" href="#resource-reporting-and-monitoring" title="Permalink to this headline">¶</a></h3>
<p>For each hardware device in Kubernetes cluster, there must be a corresponding
device plug-in to manage. and these device plug-ins connect the device plug-in
manager in Kubelet through gRPC as the client, the device plug-in reports
device name and it’s UNIX* socket API version to Kubelet.</p>
<div class="figure align-default">
<img alt="../_images/device-plugin-1.png" src="../_images/device-plugin-1.png" />
</div>
<p>Generally speaking, the whole process is divided into four steps. The first
three steps are running on the nodes. The fourth step is the interaction
between Kubelet and API server.  see below:</p>
<p>The first step is to register device plug-in. The Kubelet exports a
<code class="docutils literal notranslate"><span class="pre">Registration</span></code> gRPC service:</p>
<p>A device plug-in can register itself with the Kubelet through this gRPC
service. Kubernetes needs to know which device plug-in to interact with. This
is because there may be multiple devices on a node. Device plug-in is required
to report three things to Kubelet as a client. who am I, where am i and the
interaction protocol.  see below registration info</p>
<ul class="simple">
<li><p>The  name of its Unix socket.</p></li>
<li><p>The  Device Plug-in API version against which it was built.</p></li>
<li><p>The Resource Name to be advertised. Here Resource Name needs to follow the <a class="reference external" href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#extended-resources">extended resource naming scheme</a> as vendor-domain/resource type.</p></li>
</ul>
<p>The second step is to start a service as a gRPC server, which makes the service
ready to be accessed by a Kubelet. The listening address and
protocol API version were exposed to Kubelet in the first step.</p>
<p>Step 3: The Kubelet needs to establish a long connection for list and watch of
the device plug-in to discover the device ID and the health status of the
device. When the device plug-in detects that a device is unhealthy, it will
report the status to the Kubelet.</p>
<p>In the last of 4 steps, the device plug-in sends the Kubelet the list of
devices it manages, and the Kubelet is then in charge of advertising those
resources to the API server as part of the Kubelet node status update.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Kubelet only reports the number of specific device  to  API server. the
device plug-in manager of Kubelet itself will save the device ID list of the
device and use it for specific device allocation. for the Kubernetes
scheduler, which does not know the device ID list of the device. It only
knows the number of device.</p>
</div>
</div>
<div class="section" id="pod-scheduling-and-device-resource-allocation">
<h3>Pod Scheduling and Device Resource Allocation<a class="headerlink" href="#pod-scheduling-and-device-resource-allocation" title="Permalink to this headline">¶</a></h3>
<p>When a container application wants to use a device, it only needs to declare
the device resource and the corresponding quantity in the <em>limits</em> section of
yaml file in pod’s resource (for example intel.com/gpu:</p>
<div class="figure align-default">
<img alt="../_images/device-plugin-2.png" src="../_images/device-plugin-2.png" />
</div>
<p>The Kubernetes scheduler will then find the right node. The scheduler
will reduce 1 from the number of available devices and complete the
binding pod with node. After binding successfully, the Kubelet running on
corresponding node, is responsible for launching the container
application. Once it finds the device resource requested by the pod’s
container, it will call its internal device plug-in manager to get an
available device ID from it’s device ID list and send this allocated device ID
as the parameter to local device plug-in service. After receiving the
allocated device ID, the device plug-in will access the device driver to get
the device Path, driver directory, and environment variables of this device,
then return them to Kubelet as the allocate response. Once the device path and
driver directory information are returned to the Kubelet, the Kubelet will
perform the operation of assigning device to the container runtime as
container launching parameters. After completing device mapping and volume
mounting, it will start the container application. You can check if the device
is available to be accessed in the container. Now the device resource
allocation for container is complete. The device plug-in API design, working
mechanism, and device plug-in life cycle management are described above.</p>
</div>
<div class="section" id="handling-kubelet-restarts">
<h3>Handling Kubelet Restarts<a class="headerlink" href="#handling-kubelet-restarts" title="Permalink to this headline">¶</a></h3>
<p>A device plug-in is expected to detect Kubelet restarts and re-register itself with the new Kubelet instance. In the current implementation, a new Kubelet instance deletes all the existing Unix sockets under <code class="docutils literal notranslate"><span class="pre">/var/lib/kubelet/device-plugins</span></code> when it starts. A device plug-in can monitor the deletion of its Unix socket and re-register itself upon such an event.</p>
</div>
</div>
<div class="section" id="device-plugin-deployment">
<h2>Device Plugin Deployment<a class="headerlink" href="#device-plugin-deployment" title="Permalink to this headline">¶</a></h2>
<p>Typically, You can deploy a device plugin as a DaemonSet, or manually.</p>
<p>The canonical directory <code class="docutils literal notranslate"><span class="pre">/var/lib/kubelet/device-plugins</span></code> requires
privileged access, so a device plugin must run in a privileged security
context. If you’re deploying a device plugin as a DaemonSet, <code class="docutils literal notranslate"><span class="pre">/var/lib/kubelet/device-plugins</span></code> must be mounted as a <a class="reference external" href="https://kubernetes.io/docs/concepts/storage/volumes/">Volume</a> in the plugin’s <a class="reference external" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">PodSpec</a>.</p>
<p>If you choose the DaemonSet approach you can rely on Kubernetes to place the
device plug-in’s Pod onto Nodes, to restart the daemon Pod after failure, and
to help automate upgrades.</p>
<p>For example to deploy the DaemonSet of QAT device plug-in:</p>
<p>After installing QAT card, QAT driver installation in node, and enabling it, to deploy the QAT device plug-in you must first deploy a <a class="reference external" href="https://github.com/intel/intel-device-plugins-for-kubernetes/blob/master/deployments/qat_plugin/base/intel-qat-plugin-config.yaml">ConfigMap</a> and the <a class="reference external" href="https://github.com/intel/intel-device-plugins-for-kubernetes/blob/master/deployments/qat_plugin/base/intel-qat-plugin.yaml">DaemonSet YAML</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl create -f deployments/qat_plugin/base/intel-qat-plugin-config.yaml
$ kubectl create -f deployments/qat_plugin/base/intel-qat-plugin.yaml
</pre></div>
</div>
<p>This document describes basic knowledge of Kubernetes device plug-in design,
working mechanism. Please see the rest of the site for details and demos.</p>
<p>Intel Device Plugins for Kubernetes <a class="reference external" href="https://github.com/intel/intel-device-plugins-for-kubernetes">Github Repository</a></p>
<p>*Other names and brands may be claimed as the property of others.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gpu.html" class="btn btn-neutral float-right" title="GPU Device Plugin" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../nfd/using.html" class="btn btn-neutral float-left" title="Using Node Feature Discovery in a Kubernetes Cluster" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, various

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>